---
title: "sampling-bias-validation-prototyping"
author: "JT Miller"
date: "2024-03-20"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# A prototyping script for dealing with sampling biases in our phenology data

## Load Libraries
```{r}
library(data.table)
library(tidyverse)
library(ggplot2)
library(sqldf)
```

## Load Data
Full data is all of the data from iNaturalist and the California Cosortium (CCH2) Regardless of whether its flowering or not. This is intended to be my background sampling effort. 
Flowering data is the data from iNaturalist and the California Cosortium (CCH2) that has been restricted to only research grade records (for iNaturalist data) and flowering records (for both iNaturalist and CCH2)
```{r}
full_data <- fread("/home/jtmiller/mybook_jt/sliding-phenology/data/processed/comb_data_sf_hexed100")
flowering_data <- fread("/home/jtmiller/mybook_jt/sliding-phenology/data/processed/comb_data_rg_flowering_sf_hexed100")

# Deal with duplication if present 

full_data <- full_data %>% 
  distinct(scientificName, decimalLongitude, decimalLatitude, year, doy, .keep_all = TRUE) %>% 
  select(id, scientificName, year, doy, decimalLatitude, decimalLongitude, eventDate, coordinateUncertaintyInMeters, family, hex100_id)

flowering_data <- flowering_data %>% 
  distinct(scientificName, decimalLongitude, decimalLatitude, year, doy, .keep_all = TRUE) %>%  
  select(id, scientificName, year, doy, decimalLatitude, decimalLongitude, eventDate, coordinateUncertaintyInMeters, family, hex100_id, openFlower, reproductiveCondition)

# Change the flowering data to make a bit more succinct in terms of phenology 
flowering_data <- flowering_data %>% 
  mutate(flowering = case_when(
    openFlower == "present" ~ TRUE, 
    reproductiveCondition != "DNE in cch2" ~ TRUE, 
    TRUE ~ FALSE
  )) %>% 
  select(-reproductiveCondition, -openFlower)

full_data <- full_data %>% 
  mutate(flowering = NA) # create a place holder

all_data <- merge(full_data, flowering_data, by = c("scientificName", "year", "doy", "decimalLatitude", "decimalLongitude", "id"), all.x = TRUE)

all_data <- all_data %>% 
  mutate(flowering = case_when(
    flowering.y == TRUE ~ TRUE, 
    is.na(flowering.y) ~ FALSE
  )) %>% 
  mutate(eventDate = coalesce(eventDate.x, eventDate.y), 
         coordinateUncertaintyInMeters = coalesce(coordinateUncertaintyInMeters.x, coordinateUncertaintyInMeters.y),
         family = coalesce(family.x, family.y),
         hex100_id = coalesce(hex100_id.x, hex100_id.y)) %>% 
  select(-ends_with(".x"), -ends_with(".y"))

```


## Visualize the Uncertainty Associated with Low Sampling Effort
```{r}
full_data_eg <- all_data[hex100_id == 175]
full_data_eg <- full_data_eg[year == 2019]

flowering_eg <- full_data_eg[flowering == TRUE]

# Precleaning 
ggplot() + 
  geom_histogram(data= full_data_eg, aes(x = doy), bins = 200,fill = "lightgrey") +
  geom_histogram(data = flowering_eg, aes(x = doy), bins = 200) +
  labs(x = "Day of Year", y = "Number of Flowering Individuals") +
  ggtitle("Community Flowering") +
  scale_y_continuous(expand = c(0,0))+ 
  scale_x_continuous(limits = c(0,365))+
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5)) 

### Cleaning: Require that for each doy there be more than 2 observations and that there are more than 1 species observed in order to validate using that data 

doy_table <- full_data_eg %>%  
  group_by(doy) %>% 
  summarize(n_doy = n(), n_uniq_sp = n_distinct(scientificName), obs_sp_perc = n_distinct(scientificName)/n_doy)

# Generate a complete sequence of DOYs covering the entire year
all_doys <- data.frame(doy = 1:365)

# Left join with the existing summary table and replace NA values with "UNK"
complete_doy_table <- full_join(all_doys, doy_table, by = "doy")

doy_f_table <- complete_doy_table %>% 
  mutate(viable_doy = case_when(
    (!is.na(obs_sp_perc) & n_doy > 2 & n_uniq_sp > 1) ~ TRUE,
    is.na(obs_sp_perc) | n_doy <= 2 & n_uniq_sp <= 1 ~ FALSE, 
    TRUE ~ FALSE))

# Create a boolean output in parent data denoting what we can and cant use
full_data_egf <- full_data_eg %>% 
  mutate(doy_usable = case_when(
    doy %in% doy_f_table$doy ~ TRUE, # if the doy is within the filtered table return TRUE
    TRUE ~ FALSE # else return false
  ))

the_data <- merge(doy_f_table, full_data_eg, by = "doy", all.x = TRUE) # the parent data

the_valid_data <- the_data %>% 
  filter(viable_doy == TRUE) # check, dont use 

the_flowering_data <- the_data %>% 
  filter(flowering == TRUE) # The flowering data we will use 


### Realized Usage example 
ggplot() + 
  geom_histogram(data = the_data, aes(x = doy), bins = 200, fill = "lightgrey") +
  geom_histogram(data = the_flowering_data, aes(x = doy), bins = 200) +
  geom_rect(data = subset(the_data, viable_doy == FALSE), aes(xmin = doy - 0.5, xmax = doy + 0.5, ymin = 0, ymax = Inf), fill = "darkred", alpha = 0.2) +
  labs(x = "Day of Year", y = "Number of Flowering Individuals") +
  ggtitle("Community Flowering") +
  scale_y_continuous(expand = c(0,0)) +
  scale_x_continuous(limits = c(0,365)) +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))


```


### Extending uncertainty to modality validation
Above is a nice way of visualizing uncertainty, where the red regions are days of the year that we are not confident in the sampling effort uncovering true detection (as there is just insufficient information on observation). 

Here, I'll extend this uncertainty into the modeling of modality. That is, if a particular plant species's flowering period is obstructed by the uncertainty, we should avoid making conclusions based on the data at hand. 

If a phenologic period is well defined outside of the region of uncertainty and there are not 'rouge' flowering events located in regions of uncertainty, this suggests that we can be confident in recovering that (species + hexcell + year)'s modality.
```{r}
### Example code: 
# Reload previous steps for clarity
full_data_eg <- all_data[hex100_id == 63] # change to 175 for eg
full_data_eg <- full_data_eg[year == 2019] # change to 2017 for eg
flowering_eg <- full_data_eg[flowering == TRUE]
doy_table <- full_data_eg %>%  
  group_by(doy) %>% 
  summarize(n_doy = n(), n_uniq_sp = n_distinct(scientificName), obs_sp_perc = n_distinct(scientificName)/n_doy)
all_doys <- data.frame(doy = 1:365)
complete_doy_table <- full_join(all_doys, doy_table, by = "doy")
doy_f_table <- complete_doy_table %>% 
  mutate(viable_doy = case_when(
    (!is.na(obs_sp_perc) & n_doy > 2 & n_uniq_sp > 1) ~ TRUE,
    is.na(obs_sp_perc) | n_doy <= 2 & n_uniq_sp <= 1 ~ FALSE, 
    TRUE ~ FALSE))
full_data_egf <- full_data_eg %>% 
  mutate(doy_usable = case_when(
    doy %in% doy_f_table$doy ~ TRUE, # if the doy is within the filtered table return TRUE
    TRUE ~ FALSE # else return false
  ))
the_data <- merge(doy_f_table, full_data_eg, by = "doy", all.x = TRUE) # the parent data
the_valid_data <- the_data %>% 
  filter(viable_doy == TRUE) # check, dont use 
the_flowering_data <- the_data %>% 
  filter(flowering == TRUE) # The flowering data we will use 
# Look for eg that is well documented in this years records...
flowering_eg %>% 
  group_by(scientificName) %>% 
  summarize(n = n()) %>% 
  arrange(desc(n))

eg_species_flowering_data <- the_flowering_data %>% 
  filter(scientificName == "Albenia") # change to Justicia californica for eg

filtered_the_data <- na.omit(the_data)

ggplot() + 
  geom_histogram(data = filtered_the_data, aes(x = doy), bins = 200, fill = "lightgrey") +
  geom_histogram(data = eg_species_flowering_data, aes(x = doy), bins = 200) +
  geom_rect(data = subset(the_data, viable_doy == FALSE), aes(xmin = doy - 0.5, xmax = doy + 0.5, ymin = 0, ymax = Inf), fill = "darkred", alpha = 0.2) +
  labs(x = "Day of Year", y = "Number of Flowering Individuals") +
  ggtitle("Community Flowering") +
  scale_y_continuous(expand = c(0,0)) +
  scale_x_continuous(limits = c(0,365)) +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))

# Now that we have an example...lets try setting some ground rules. To justify modality lets set a threshold of continuous 10 days of uncertainty between flowering periods to invalidate conclusions for that particular (species + hexcell + year), meaning that we are uncertain as to whether modality can be properly concluded without proper detection.

# Calculate consecutive lengths of runs where viable_doy == FALSE
consecutive_false <- function(x) {
  run_lengths <- integer(length(x))
  current_run <- 0
  
  for (i in seq_along(x)) {
    if (!x[i]) {
      current_run <- current_run + 1
      run_lengths[i] <- current_run
    } else {
      current_run <- 0
    }
  }
  
  run_lengths
}

the_data2 <- the_data %>%
  distinct(doy, .keep_all = TRUE) %>% 
  arrange(doy) %>%
  mutate(run_lengths = consecutive_false(viable_doy))

the_data3 <- the_data2 %>% 
  select(doy, viable_doy, run_lengths)

### Try Simplifying the problem a bit:
df <- the_data3 %>% 
  mutate(transitions = ifelse(run_lengths == 0, 0, 1))
g_df <- df %>%
  group_by(grp = rleid(transitions)) %>% 
  mutate(seq_of_ten =  +(n() >= 10 & all(transitions == 1)))

filtered_the_data <- na.omit(the_data)
# Test 
ggplot() + 
  geom_histogram(data = filtered_the_data, aes(x = doy), bins = 200, fill = "lightgrey") +
  geom_histogram(data = eg_species_flowering_data, aes(x = doy), bins = 200) +
  geom_rect(data = subset(the_data, viable_doy == FALSE), aes(xmin = doy - 0.5, xmax = doy + 0.5, ymin = 0, ymax = Inf), fill = "darkred", alpha = 0.2) +
  labs(x = "Day of Year", y = "Number of Flowering Individuals") +
  ggtitle("Community Flowering") +
  scale_y_continuous(expand = c(0,0)) +
  scale_x_continuous(limits = c(0,365)) +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))


ggplot() + 
  geom_histogram(data = filtered_the_data, aes(x = doy), bins = 200, fill = "lightgrey") +
  geom_histogram(data = eg_species_flowering_data, aes(x = doy), bins = 200) +
  geom_rect(data = subset(g_df, seq_of_ten == 1), aes(xmin = doy - 0.5, xmax = doy + 0.5, ymin = 0, ymax = Inf), fill = "darkred", alpha = 0.2) +
  labs(x = "Day of Year", y = "Number of Flowering Individuals") +
  ggtitle("Community Flowering") +
  scale_y_continuous(expand = c(0,0)) +
  scale_x_continuous(limits = c(0,365)) +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))


```
### Assigning confidence to a specis + hexcell + year delimitation
Create a field that denotes whether the distribution of records is interrupted by regions of low confidence 
```{r}
confidence_df <- merge(g_df, eg_species_flowering_data, all.x = TRUE)
confidence_dt <- as.data.table(confidence_df)

## Build some coords to eval the betweenn cases 
# Identify the sequences of 1s
sequences <- rle(g_df$seq_of_ten)
seq_start <- cumsum(sequences$lengths) - sequences$lengths + 1
seq_end <- cumsum(sequences$lengths)

# Extract min and max doy values for each sequence
min_max_doy <- sapply(seq_start[sequences$values == 1], function(start_idx) {
  end_idx <- seq_end[which(seq_start == start_idx)]
  min_max <- c(min(df$doy[start_idx:end_idx]), max(df$doy[start_idx:end_idx]))
  return(min_max)
})

# Extract coordinates for each sequence
coordinates <- lapply(seq_start[sequences$values == 1], function(start_idx) {
  end_idx <- seq_end[which(seq_start == start_idx)]
  coords <- g_df[start_idx:end_idx, c("doy", "seq_of_ten")]
  coords <- coords[coords$seq_of_ten == 1, "doy"]
  return(coords)
})

if(length(coordinates) > 0){
range <- data.table()
for(i in 1:length(coordinates)){
temp_range <- data.table(start = min(coordinates[[i]]$doy), end = max(coordinates[[i]]$doy))
range <- rbind(range, temp_range)
}
} else{
  range <- data.frame(start = 0, end = 0)
}

# Test if the sequence of flowering data for a plant species + hexcell + year contains uncertainty 
if(min(range$start) != 0 & max(range$end) != 0){
sp_min_phen <- min(eg_species_flowering_data$doy)
sp_max_phen <- max(eg_species_flowering_data$doy)
sp_known_seq <- seq(sp_min_phen, sp_max_phen)


confidence_test <- ifelse(any(sp_known_seq %in% seq(min(range$start),max(range$end))), TRUE, FALSE)
} else{
  confidence_test <- FALSE
}

# confidence_dt[inrange(confidence_dt[!is.na(scientificName)], range$start, range$end)]
# confidence_dt[doy %inrange% c(range[1,1], range[1,2])]
# confidence_dt[doy %inrange% c(range[2,1], range[2,2])]
# confidence_dt[doy %inrange% c(range[3,1], range[3,2])]


confidence_summary <- data.table(scientificName = unique(eg_species_flowering_data$scientificName), hex100_id = unique(eg_species_flowering_data$hex100_id), year = unique(eg_species_flowering_data$year), distributionContainsObsUncertainty = confidence_test, lowerUncertaintyDOYBound = min(range$start), upperUncertaintyDOYBound = max(range$end))


  
```


### Write functions to accomplish this so we can interate through all of the data efficiently 
```{r}
### Function IdentifyObservationalUncertainty #######################################################################################################

IdentifyObservationalUncertainty <- function(data, target_scientificName, target_year, hex_cell, dir_path_gen, dir_path_spec, dir_path_conf_summary, dir_path_flowering_sp_subset){
  background_subset <- data[hex100_id == hex_cell & year == target_year] # subset the all background data
  sp_flowering_subset <- background_subset[scientificName == target_scientificName & flowering == TRUE] # species of interest and flowering
  
  doy_table <- background_subset %>%  # create a summary for doy field 
  group_by(doy) %>% 
  summarize(n_doy = n(), n_uniq_sp = n_distinct(scientificName), obs_sp_perc = n_distinct(scientificName)/n_doy)
  
  all_doys <- data.frame(doy = 1:365) # create a default summary of doys
  
  complete_doy_table <- full_join(all_doys, doy_table, by = "doy") # full join the dataframes

  doy_f_table <- complete_doy_table %>% # Create a final doy table that notes viable doy's according to specifications (currently arbitrary)
    mutate(viable_doy = case_when(
      (!is.na(obs_sp_perc) & n_doy > 2 & n_uniq_sp > 1) ~ TRUE,
      is.na(obs_sp_perc) | n_doy <= 2 & n_uniq_sp <= 1 ~ FALSE, 
      TRUE ~ FALSE))
  
  background_subset_f <- background_subset %>% 
    mutate(doy_usable = case_when(
      doy %in% doy_f_table$doy ~ TRUE, # if the doy is within the filtered table return TRUE
      TRUE ~ FALSE # else return false
      ))
  
  ordinal_data <- merge(doy_f_table, background_subset_f, by = "doy", all.x = TRUE) # merge to create a full calendar year relevant set
  
  ordinal_data_na_drop <- na.omit(ordinal_data) # drop na's for visualization purposes 
  
  # Plot the generalized observation detection error
  generalized_plot <- ggplot() + 
  geom_histogram(data = ordinal_data_na_drop, aes(x = doy, fill = "background"), bins = 200) +
  geom_histogram(data = sp_flowering_subset, aes(x = doy, fill = "flowering"), bins = 200) +
  geom_rect(data = subset(ordinal_data, viable_doy == FALSE), aes(xmin = doy - 0.5, xmax = doy + 0.5, ymin = 0, ymax = Inf, fill = "uncertainty"), alpha = 0.2) +
  labs(x = "Day of Year", y = "Number of Flowering Individuals") +
  ggtitle(paste("Generalized Community coverage and Observation Error for hex cell", hex_cell, "& year", target_year,"\n", "with", target_scientificName, "flowering" )) +
  scale_y_continuous(expand = c(0,0)) +
  scale_x_continuous(limits = c(0,365)) +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5)) +
  scale_fill_manual(name = "Legend",
                    values = c("background" = "lightgrey", "flowering" = "black", "uncertainty" = "darkred"),
                    labels = c("Community Background Coverage", paste("Flowering Records for", target_scientificName), "Observational Uncertainty"))
  # Calculate consecutive lengths of runs where viable_doy == FALSE
consecutive_false <- function(x) {
  run_lengths <- integer(length(x))
  current_run <- 0
  
  for (i in seq_along(x)) {
    if (!x[i]) {
      current_run <- current_run + 1
      run_lengths[i] <- current_run
    } else {
      current_run <- 0
    }
  }
  
  run_lengths
}

ordinal_data2 <- ordinal_data %>%
  distinct(doy, .keep_all = TRUE) %>% 
  arrange(doy) %>%
  mutate(run_lengths = consecutive_false(viable_doy))

ordinal_data3 <- ordinal_data2 %>% 
  select(doy, viable_doy, run_lengths)

df <- ordinal_data3 %>% 
  mutate(transitions = ifelse(run_lengths == 0, 0, 1))
g_df <- df %>%
  group_by(grp = rleid(transitions)) %>% 
  mutate(seq_of_ten =  +(n() >= 10 & all(transitions == 1)))

# Plot the Special Case observation detection error
  specialized_plot <- ggplot() + 
  geom_histogram(data = ordinal_data_na_drop, aes(x = doy, fill = "background"), bins = 200) +
  geom_histogram(data = sp_flowering_subset, aes(x = doy, fill = "flowering"), bins = 200) +
  geom_rect(data = subset(g_df, seq_of_ten == 1), aes(xmin = doy - 0.5, xmax = doy + 0.5, ymin = 0, ymax = Inf, fill = "uncertainty"), alpha = 0.2) +
  labs(x = "Day of Year", y = "Number of Flowering Individuals") +
  ggtitle(paste("Specialized Case Community coverage and Observation Error for hex cell", hex_cell, "& year", target_year,"\n", "with", target_scientificName, "flowering" )) +
  scale_y_continuous(expand = c(0,0)) +
  scale_x_continuous(limits = c(0,365)) +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5)) +
  scale_fill_manual(name = "Legend",
                    values = c("background" = "lightgrey", "flowering" = "black", "uncertainty" = "darkred"),
                    labels = c("Community Background Coverage", paste("Flowering Records for", target_scientificName), "Observational Uncertainty"))
  
  
  filestyle_target_scientificName <- gsub(" ", "-", target_scientificName)
  
  ggsave(filename = paste0("generalizedObsUncPlot_", hex_cell, "_", target_year, "_", filestyle_target_scientificName, ".png"), plot = generalized_plot, path = dir_path_gen, width = 20, height = 15)
  ggsave(filename = paste0("specializedObsUncPlot_", hex_cell, "_", target_year, "_", filestyle_target_scientificName, ".png"), plot = specialized_plot, path = dir_path_spec, width = 20, height = 15)
  
  # Last steps to build table 
  confidence_df <- merge(g_df, sp_flowering_subset, all.x = TRUE)
  confidence_dt <- as.data.table(confidence_df)

  ## Build some coords to eval the between cases 
  # Identify the sequences of 1s
  sequences <- rle(g_df$seq_of_ten)
  seq_start <- cumsum(sequences$lengths) - sequences$lengths + 1
  seq_end <- cumsum(sequences$lengths)

  # Extract min and max doy values for each sequence
  min_max_doy <- sapply(seq_start[sequences$values == 1], function(start_idx) {
    end_idx <- seq_end[which(seq_start == start_idx)]
    min_max <- c(min(df$doy[start_idx:end_idx]), max(df$doy[start_idx:end_idx]))
    return(min_max)
  })

  # Extract coordinates for each sequence
  coordinates <- lapply(seq_start[sequences$values == 1], function(start_idx) {
    end_idx <- seq_end[which(seq_start == start_idx)]
    coords <- g_df[start_idx:end_idx, c("doy", "seq_of_ten")]
    coords <- coords[coords$seq_of_ten == 1, "doy"]
    return(coords)
  })

  if(length(coordinates) > 0){
  range <- data.table()
  for(i in 1:length(coordinates)){
    temp_range <- data.table(start = min(coordinates[[i]]$doy), end = max(coordinates[[i]]$doy))
    range <- rbind(range, temp_range)
  }
  } else{
    range <- data.frame(start = 0, end = 0)
  }

  # Test if the sequence of flowering data for a plant species + hexcell + year contains uncertainty 
  if(min(range$start) != 0 & max(range$end) != 0){
    sp_min_phen <- min(sp_flowering_subset$doy)
    sp_max_phen <- max(sp_flowering_subset$doy)
    sp_known_seq <- seq(sp_min_phen, sp_max_phen)


    confidence_test <- ifelse(any(sp_known_seq %in% seq(min(range$start),max(range$end))), TRUE, FALSE)
  } else{
    confidence_test <- FALSE
  }


    confidence_summary <- data.table(scientificName = unique(sp_flowering_subset$scientificName), hex100_id = unique(sp_flowering_subset$hex100_id), year = unique(sp_flowering_subset$year), distributionContainsObsUncertainty = confidence_test, lowerUncertaintyDOYBound = min(range$start), upperUncertaintyDOYBound = max(range$end))

fwrite(confidence_summary, file = paste0(dir_path_conf_summary, "confidence-summary_", hex_cell, "_", target_year, "_", filestyle_target_scientificName, ".csv"))

fwrite(sp_flowering_subset, file = paste0(dir_path_flowering_sp_subset, "flowering-record-subset_", hex_cell, "_", target_year, "_", filestyle_target_scientificName, ".csv") )
         
}

#####################################################################################################################################################
# test
test <- IdentifyObservationalUncertainty(data = all_data, target_scientificName = "Justicia californica", target_year = 2017, hex_cell = 175, dir_path_gen = "/srv/mybook/jtmiller/sliding-phenology/fig_outputs/generalized-obs-error-plots/", dir_path_spec = "/srv/mybook/jtmiller/sliding-phenology/fig_outputs/specialized-obs-error-plots/", dir_path_conf_summary = "/srv/mybook/jtmiller/sliding-phenology/data/processed/confidence-summaries/", dir_path_flowering_sp_subset = "/srv/mybook/jtmiller/sliding-phenology/data/processed/flowering-data-subsets/")

check <- fread("/srv/mybook/jtmiller/sliding-phenology/data/processed/confidence-summaries/confidence-summary_175_2017_Justicia-californica.csv")
check_f <- fread("/srv/mybook/jtmiller/sliding-phenology/data/processed/flowering-data-subsets/flowering-record-subset_175_2017_Justicia-californica.csv")

```

### Now do this for all (species + hex_cell + year)
```{r}
all_flowering_data <- all_data[flowering == TRUE]
uniq_hex_cells <- unique(all_flowering_data$hex100_id) # Organize By Hexcell
#indices <- which(uniq_hex_cells %in% c(175)) # Loop takes a long time, so focal region for now
#uniq_hex_cells <- uniq_hex_cells[indices]

for(i in 1:length(uniq_hex_cells)){
  
  target_hex_cell <- uniq_hex_cells[[i]]
  data_by_hex <- all_data[hex100_id == target_hex_cell]
  only_flowering_names <- data_by_hex[flowering == TRUE] # fix issue with non-existant flowerers
  uniq_names <- unique(only_flowering_names$scientificName)
  for(j in 1:length(uniq_names)){
    target_name <- uniq_names[[j]]
    data_by_name <- data_by_hex[scientificName == target_name]
    only_years_by_flowering_names <- data_by_name[flowering == TRUE] # fix issue with non-existent flowerers
    uniq_years_by_name <- unique(only_years_by_flowering_names$year)
    for(w in 1:length(uniq_years_by_name)){
    target_year <- uniq_years_by_name[[w]]
    IdentifyObservationalUncertainty(data = all_data, target_scientificName = target_name, target_year = target_year, hex_cell = target_hex_cell, dir_path_gen = "/srv/mybook/jtmiller/sliding-phenology/fig_outputs/generalized-obs-error-plots/", dir_path_spec = "/srv/mybook/jtmiller/sliding-phenology/fig_outputs/specialized-obs-error-plots/", dir_path_conf_summary = "/srv/mybook/jtmiller/sliding-phenology/data/processed/confidence-summaries/", dir_path_flowering_sp_subset = "/srv/mybook/jtmiller/sliding-phenology/data/processed/flowering-data-subsets/")}
    
  }
  
}


check <- all_data[scientificName == "Abelia" & hex100_id == 63]
```






Try Visualizing the Uncertainty in the kde 2
```{r}
library(kde1d) # creates kernel density plots
library(diptest) # tests for multimodality

kde.sims <- kde1d(x = eg_species_flowering_data$doy)


plot(kde.sims, main = "kernel Density Estimation", xlab = "day of year", xlim = c(0,365))
abline(v = min(subset(g_df, g_df$seq_of_ten == 1)$doy), col = "red")


# Identify the sequences of 1s
sequences <- rle(g_df$seq_of_ten)
seq_start <- cumsum(sequences$lengths) - sequences$lengths + 1
seq_end <- cumsum(sequences$lengths)

# Extract min and max doy values for each sequence
min_max_doy <- sapply(seq_start[sequences$values == 1], function(start_idx) {
  end_idx <- seq_end[which(seq_start == start_idx)]
  min_max <- c(min(df$doy[start_idx:end_idx]), max(df$doy[start_idx:end_idx]))
  return(min_max)
})

# Extract coordinates for each sequence
coordinates <- lapply(seq_start[sequences$values == 1], function(start_idx) {
  end_idx <- seq_end[which(seq_start == start_idx)]
  coords <- g_df[start_idx:end_idx, c("doy", "seq_of_ten")]
  coords <- coords[coords$seq_of_ten == 1, "doy"]
  return(coords)
})

test <- coordinates[[1]]
xx <- c(range[1,1], range[1,2], range[2,1], range[2,2], range[3,1], range[3,2])
x <- c(min(test$doy), max(test$doy))
plot(kde.sims, main = "kernel Density Estimation", xlab = "day of year", xlim = c(0,365))
polygon(coordinates[[1]]$doy, "red")




```